// libs
import 'jest';
import { NextFunction, Request, Response } from 'express';

import { commentController } from "@/controllers";
import { postService, commentServices } from '@/services';
import { MESSAGES, MESSAGES_AUTHENTICATION, PAGINATION, STATUS_CODE } from '@/constants';
import { MOCKS_COMMENTS_INCLUDE_POST_USER, MOCKS_POSTS } from '@/mocks';
import HttpExceptionError from '@/exceptions';

describe('Post controller', () => {
  let req: Partial<Request>;
  let res: Partial<Response>;
  let next: Partial<NextFunction>;
  const { OFFSET, LIMIT } = PAGINATION.DEFAULT;
  const { UPDATE } = MESSAGES.SUCCESS;

  beforeEach(() => {
    req = {
      query: {
        offset: OFFSET.toString(),
        limit: LIMIT.toString(),
      },
      params: {
        userId: '1',
        id: '1',
        commentId: '8'
      },
      body: {
        content: 'This is a comment',
        postId: 1,
        authorId: 0
      }
    };
    res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn()
    };

    next = jest.fn();
  });

  afterEach(() => {
    jest.clearAllMocks();
    
  });

  describe('Get Post\'s comments', () => {
    it('should return post\'s comments', async () => {
      (commentServices.getPostsComment as jest.Mock) = jest.fn();
      (commentServices.getPostsComment as jest.Mock).mockResolvedValueOnce(MOCKS_COMMENTS_INCLUDE_POST_USER);

      await commentController.getPostsComment(req as Request, res as Response, next as NextFunction);

      expect(commentServices.getPostsComment).toHaveBeenCalledWith(0, 10, 1);
      expect(res.status).toHaveBeenCalledWith(STATUS_CODE.OK);
      expect(res.json).toHaveBeenCalledWith({ data: MOCKS_COMMENTS_INCLUDE_POST_USER });
    });

    it('should handle error when get post\'s comments', async () => {
      const error = new HttpExceptionError(STATUS_CODE.INTERNAL_SERVER_ERROR, MESSAGES_AUTHENTICATION.INTERNAL_SERVER_ERROR);
      (commentServices.getPostsComment as jest.Mock).mockRejectedValueOnce(error);

      await commentController.getPostsComment(req as Request, res as Response, next as NextFunction);

      expect(next).toHaveBeenCalledWith(error);
    });
  });

  describe('Get Post\'s comment by ID', () => {
    it('should return post\'s comment by ID', async () => {
      (commentServices.getPostsCommentById as jest.Mock) = jest.fn();
      (commentServices.getPostsCommentById as jest.Mock).mockResolvedValueOnce(MOCKS_COMMENTS_INCLUDE_POST_USER[0]);

      await commentController.getPostsCommentById(req as Request, res as Response, next as NextFunction);

      expect(commentServices.getPostsCommentById).toHaveBeenCalledWith(8, 1);
      expect(res.status).toHaveBeenCalledWith(STATUS_CODE.OK);
      expect(res.json).toHaveBeenCalledWith({ data: MOCKS_COMMENTS_INCLUDE_POST_USER[0] });
    });

    it('should handle error when get post\'s comment by ID', async () => {
      const error = new HttpExceptionError(STATUS_CODE.NOT_FOUND, MESSAGES.ERRORS.COMMENT.NOT_FOUND);
      (commentServices.getPostsCommentById as jest.Mock).mockRejectedValueOnce(error);

      await commentController.getPostsCommentById(req as Request, res as Response, next as NextFunction);

      expect(next).toHaveBeenCalledWith(error);
    });

    it('should handle error Authentication faild when get post\'s comment by ID', async () => {
      const error = new HttpExceptionError(
        STATUS_CODE.INTERNAL_SERVER_ERROR,
        MESSAGES_AUTHENTICATION.INTERNAL_SERVER_ERROR
      );
      (commentServices.getPostsCommentById as jest.Mock).mockRejectedValueOnce(error);

      await commentController.getPostsCommentById(req as Request, res as Response, next as NextFunction);

      expect(next).toHaveBeenCalledWith(error);
    });
  });

  describe('Create Post\'s comment', () => {
    it('should create a post\'s comment', async () => {
      (postService.get as jest.Mock) = jest.fn();
      (postService.get as jest.Mock).mockResolvedValueOnce(MOCKS_POSTS[0]);
      (commentServices.create as jest.Mock) = jest.fn();
      (commentServices.create as jest.Mock).mockResolvedValueOnce(MOCKS_COMMENTS_INCLUDE_POST_USER[0]);

      await commentController.postPostsComments(req as Request, res as Response, next as NextFunction);

      expect(postService.get).toHaveBeenCalledWith(1);
      expect(commentServices.create).toHaveBeenCalledWith({
        postId: 1,
        authorId: 0,
        content: req.body.content
      });
      expect(res.status).toHaveBeenCalledWith(STATUS_CODE.CREATED);
      expect(res.json).toHaveBeenCalledWith({ data: MOCKS_COMMENTS_INCLUDE_POST_USER[0] });
    });

    it('should handle error when creating a post\'s comment', async () => {
      const error = new HttpExceptionError(STATUS_CODE.NOT_FOUND, MESSAGES.ERRORS.POST.NOT_FOUND);
      (postService.get as jest.Mock).mockRejectedValueOnce(error);

      await commentController.postPostsComments(req as Request, res as Response, next as NextFunction);

      expect(next).toHaveBeenCalledWith(error);
    });

    it('should handle error Authentication faild when creating a post\'s comment', async () => {
      const error = new HttpExceptionError(STATUS_CODE.INTERNAL_SERVER_ERROR, MESSAGES_AUTHENTICATION.INTERNAL_SERVER_ERROR);
      (postService.get as jest.Mock).mockRejectedValueOnce(error);

      await commentController.postPostsComments(req as Request, res as Response, next as NextFunction);

      expect(next).toHaveBeenCalledWith(error);
    });
  });

  describe('Delete Post\'s comments', () => {
    it('should delete post\'s comments', async () => {
      (commentServices.deletePostsComments as jest.Mock) = jest.fn();
      (commentServices.deletePostsComments as jest.Mock).mockResolvedValueOnce(1);

      await commentController.deletePostsComments(req as Request, res as Response, next as NextFunction);

      expect(commentServices.deletePostsComments).toHaveBeenCalledWith(1);
      expect(res.status).toHaveBeenCalledWith(STATUS_CODE.NO_CONTENT);
    });

    it('should handle error when deleting post\'s comments', async () => {
      const error = new HttpExceptionError(STATUS_CODE.INTERNAL_SERVER_ERROR, MESSAGES_AUTHENTICATION.INTERNAL_SERVER_ERROR);
      (commentServices.deletePostsComments as jest.Mock).mockRejectedValueOnce(error);

      await commentController.deletePostsComments(req as Request, res as Response, next as NextFunction);

      expect(next).toHaveBeenCalledWith(error);
    });
  });

  describe('Delete Post\'s comment by ID', () => {
    it('should delete post\'s comment by ID', async () => {
      (commentServices.deletePostsCommentById as jest.Mock) = jest.fn();
      (commentServices.deletePostsCommentById as jest.Mock).mockResolvedValueOnce(1);

      await commentController.deletePostsCommentById(req as Request, res as Response, next as NextFunction);

      expect(commentServices.deletePostsCommentById).toHaveBeenCalledWith(1, 8);
      expect(res.status).toHaveBeenCalledWith(STATUS_CODE.NO_CONTENT); 
      expect(res.json).toHaveBeenCalledWith({ data: 1, message: MESSAGES.SUCCESS.DELETE });
    });
    it('should handle error when deleting post\'s comment by ID', async () => {
      const error = new HttpExceptionError(STATUS_CODE.BAD_REQUEST, MESSAGES.ERRORS.COMMENT.NOT_FOUND_COMMENT_OR_POST);
      (commentServices.deletePostsCommentById as jest.Mock).mockRejectedValueOnce(error);

      await commentController.deletePostsCommentById(req as Request, res as Response, next as NextFunction);

      expect(next).toHaveBeenCalledWith(error);
    });

    it('should handle error authen when deleting post\'s comments', async () => {
      const error = new HttpExceptionError(STATUS_CODE.INTERNAL_SERVER_ERROR, MESSAGES_AUTHENTICATION.INTERNAL_SERVER_ERROR);
      (commentServices.deletePostsCommentById as jest.Mock).mockRejectedValueOnce(error);

      await commentController.deletePostsCommentById(req as Request, res as Response, next as NextFunction);

      expect(next).toHaveBeenCalledWith(error);
    });
  });
});